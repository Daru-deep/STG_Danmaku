# Rubric (1–5)

## 1) P0安定性（クラッシュ/Null/例外）
- 5: 例外ほぼゼロ。ガード/Validate/再発防止まで揃う。
- 4: 例外は潰せる。再発も少ない。
- 3: 潰せるが追跡が重い。ガード不足が残る。
- 2: 例外が頻発。参照寿命（Destroy/プール）が不安定。
- 1: クラッシュ級が止まらない。

## 2) バグ調査力（再現→切り分け→原因→修正）
- 5: 最短で再現・原因特定。ログ設計も上手い。
- 4: 原因特定まで到達。手順も再利用できる。
- 3: 方向は合うが遠回りが多い。
- 2: 当てずっぽうになりがち。再現条件が曖昧。
- 1: 追跡できず偶然頼み。

## 3) 次の一手（やり方提案・設計案）
- 5: 3案出せる。選定理由と拡張性が説明できる。
- 4: 2案以上出せる。実装手順に落とせる。
- 3: 1案は出るが、比較や落とし込みが弱い。
- 2: 迷子が多い。設計の言語化が難しい。
- 1: 手が止まり続ける。

## 4) Unityライフサイクル耐性
- 5: Awake/Start/OnEnable、Destroy/Disable、プールを常に意識。
- 4: 重大事故は避けられる。ガードも入る。
- 3: 基本はOKだが、例外的ケースで崩れる。
- 2: 実行順や参照寿命でよく事故る。
- 1: ライフサイクル由来のバグが常態化。

## 5) アーキ設計（責務/依存/拡張性）
- 5: 責務が明確。依存の向きが綺麗で拡張しやすい。
- 4: 大枠は良い。小さな歪みは把握している。
- 3: 動くが、肥大化/密結合の芽がある。
- 2: God classや依存逆流が目立つ。
- 1: 追加が怖くて触れない構造。

## 6) 可読性（命名・一貫性・読みやすさ）
- 5: 目的が一読で分かる。命名と構造が揃っている。
- 4: 概ね読みやすい。局所の改善で済む。
- 3: 追えば分かる。命名/構造の揺れが残る。
- 2: 意図が読み取りづらい。長い関数が多い。
- 1: 解読が必要。

## 7) 保守性（変更容易性）
- 5: 変更が局所で済む。テスト/ログ導線もある。
- 4: 変更手順が明確。副作用が少ない。
- 3: 変更できるが、影響範囲が広がりがち。
- 2: 変更するたび壊れる。依存が絡みすぎ。
- 1: 触れない。

## 8) パフォーマンス/GC
- 5: Update/Instantiate/GCの地雷を回避。必要なら計測もできる。
- 4: 重大な無駄は避けられる。
- 3: 動くが、場面で重くなる可能性がある。
- 2: 毎フレーム生成/Find/アロケが多い。
- 1: 常に重い/カクつく。

---

# Weights (for overall score)
- p0_stability: 0.20
- bug_investigation: 0.15
- next_step: 0.15
- unity_lifecycle: 0.10
- architecture: 0.15
- readability: 0.10
- maintainability: 0.10
- performance_gc: 0.05

Overall (0–100):
overall = (Σ(score_i * weight_i) / 5) * 100
